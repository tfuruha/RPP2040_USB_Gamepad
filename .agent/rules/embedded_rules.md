# PlatformIO / 組み込み開発用ルール

本ルールは、PlatformIOを用いた高品質な組み込みソフトウェア開発のためのガイドラインです。

## 1. 基本方針（非ブロッキングと時間管理）
1. **優先順位**: 堅牢性・安全性 > 可読性 > 再利用性 > 保守性 > ファイルサイズ。
2. **言語**: モダンC++ (C++17以上) を基本とし、型安全性を重視する。
3. **完全非ブロッキング**: `delay()` の使用を厳禁し、すべてのイベントを「時間監視」と「状態遷移（FSM）」の組み合わせで処理せよ。
4. **累積誤差の排除**: 定期実行タスクにおいて `millis() + INTERVAL` による次回の実行時刻計算を禁止する。実行時間のジッタと累積誤差を防ぐため、必ず `last_execution_time += INTERVAL` （前回の基準時刻への加算）の形式を採用し、長期的な周期精度を維持せよ。
推奨例
''' C++
// include/utils.h
/**
 * 非ブロッキング周期判定（累積誤差排除版）
 * @param last_us タスクごとの最終実行時刻（参照渡し）
 * @param interval_us 実行周期（マイクロ秒）
 */
inline bool checkInterval(uint32_t &last_us, uint32_t interval_us) {
    uint32_t now = micros();
    if (now - last_us >= interval_us) {
        last_us += interval_us; // 基準時刻をインターバル分進める
        return true;
    }
    return false;
}

// src/main.cpp での使用例
uint32_t motor_us = 0;
uint32_t status_us = 0;
static const uint32_t MOTOR_INTERVAL = 1000;
static const uint32_t STATUS_INTERVAL = 100000;
void setup() {
    motor_us = micros();
    status_us = micros();
}
void loop() {

    // 1ms (1000us) 周期のモーター制御
    if (checkInterval(motor_us, MOTOR_INTERVAL)) {
        motor.update();
    }

    // 100ms (100000us) 周期のステータス出力
    if (checkInterval(status_us, STATUS_INTERVAL)) {
        Serial.println("System OK");
    }
}
'''
禁止例
''' C++
// src/main.cpp での使用 
void loop() {
  sendCanMessage();
  delay(1); // 1ms待機（この間他の処理が止まるため禁止）
}
'''
''' C++
// src/main.cpp での使用 
void loop() {
  // 次の実行時刻まで他処理を待機させる（ブロッキング処理）
  while (micros() < next_us) {
    // 受信バッファの常時監視
  }

}
'''

## 2. リアルタイム性とISR（割り込み）
1. **ISR最小化の原則**: 外部割り込みやタイマー割り込み内の処理は、フラグセット、カウンタ更新、時刻記録（timestamp）のみに限定せよ。
2. **メインループへの移譲**: 重い演算、チャタリング判定、シリアル出力、I2C通信等の処理は、ISRからフラグを受け取ったメインループ側で非同期に実行せよ。
3. **制御周期の配慮**: 割り込みからメインループへ処理を移譲する際は、メインループの周期が制御周期に対して十分に高速であることを確認し、処理遅延が制御系（PID等）に与える影響に配慮せよ。

## 3. I/O負荷分散（Time-slicing）
1. **処理の分割**: `Serial.print` や I2C/SPIディスプレイへの描画など、時間のかかるI/O処理は1回のループで一括実行せず、処理を分割（1ループ1項目更新など）して実行時間を分散せよ。
2. **優先順位の明確化**: 「データのキャプチャ（高優先）」と「人間への表示（低優先）」の優先順位を分離し、アイドル時間や低頻度スロットを活用して表示処理を行え。これにより、センサー入力の取りこぼしや計測ジッタを最小化せよ。

## 4. プロジェクト構造
- `platformio.ini`: 環境設定を集約（バージョン固定、ビルドフラグ活用）。
- `include/ProjectConfig.h`: ピンアサイン、定数などの全設定を集約。
- `lib/`: 機能単位（Sensor, Actuator, Controller等）でモジュール化し、再利用性を高める。
- `src/main.cpp`: 軽量なエントリーポイントに留める。

## 5. コーディング規約
- **型指定**: `uint8_t`, `int32_t` 等の明示的なサイズ指定を使用する。
- **物理量**: 変数名に単位を付与する (`timeout_ms`, `voltage_mv`)。
- **マジックナンバー禁止**: すべて `static constexpr` または `enum class` で定数化する。
- **メモリ管理**: 動的メモリ確保 (`new`, `malloc`, `std::vector`) は原則禁止。静的な `std::array` 等を使用する。

## 6. ハードウェア抽象化とエラー処理
- **依存性注入 (DI)**: ピン番号やI2Cインスタンスをクラス内でハードコードせず、コンストラクタで受け取る。
- **通信**: I2C/SPI通信には必ずリトライとタイムアウト処理を実装する。リトライ回数は原則**3回**までとし、上限到達時は無限ループさせずエラー状態を保持し、システムを安全な状態（待機、出力停止等）へ移行させること。
- **戻り値チェック**: 初期化や通信の成否を必ず確認し、例外系を処理する。
- **Logger**: `Serial.print` を直接使用せず、ログレベル制御可能なラッパークラス（`Logger`）を経由する。

## 7. リファクタリング時のリスク評価とレビュープロセス

### 基本原則
1. **すべてのリファクタリング提案は変更規模に応じた評価が必須**
2. **リスク評価なしでの実装は禁止**
3. **リスクレベル「高」の場合は必ず代替案を検討**

### リスク評価の重点項目（組込み特有）
以下の要素を持つコードは特に慎重に評価すること：
1. **タイミング関連**: `millis()`、`micros()`、タイマー割り込み、待機処理（`delayMicroseconds()`等）。
2. **性能測定・デバッグ**: 条件付きコンパイル（`#ifdef DEBUG`等）、パフォーマンスカウンタ、統計取得コード、トレース用シリアル出力。
3. **リアルタイム性**: 割り込みハンドラ（ISR）、定周期処理（制御ループ等）、通信タイミング制御。

### 削除コードの扱い
コードを削除する場合は必ず以下を確認：
1. **用途分析**: なぜそのコードが存在し、過去にどのような問題を解決したかを確認。
2. **削除判断**: 完全に不要であれば削除可。デバッグ用途の場合は条件付きコンパイルで保持。用途不明や影響範囲不明な場合は削除不可。
3. **保護マーカー**: `// KEEP`, `// DO NOT REMOVE`, `// DEBUG`, `// PERFORMANCE` 等のマーカーがあるコードは削除前に必ず確認せよ。

### レビューおよび実施フロー
変更規模（大規模・中規模・小規模）に応じ、`templates/review/` 配下の適切なテンプレート（`full`, `quick`, `minimal`）を使用してリスク評価と提案書作成を行い、事前の承認を得てから実装に進むこと。

## 8. AIへの特別指示
- **設計戦略の提示**: コード生成前、特にループ構造やタイミング制御を設計する際は、上記の「累積誤差排除」と「I/O負荷分散」をどのように実現するか、その戦略を思考プロセスにおいて日本語で提示せよ。
- 生成したコードが `platformio.ini` の設定（ピン定義、依存ライブラリ）と整合しているか必ず確認すること。
- **PlatformIO CLI の呼び出し**: Agent 実行環境では PATH が保証されない。**PlatformIO CLI（pio）は PATH 非依存で確実に実行できるように、以下のパスを環境変数またはチルド展開後の実体として使用すること**
  - Windows: `%USERPROFILE%\.platformio\penv\Scripts\pio.exe`
  - macOS/Linux: `~/.platformio/penv/bin/pio`
- **実行時の制約**:
  - `pio` コマンドを `PATH` 依存で呼び出さないこと（常に上記フルパスを環境変数展開後に使用せよ）。
  - **禁止事項**:
    - `pio` というコマンド名のみでの実行。
    - VS Code 拡張の内部フォルダからパスを推測して使うこと。
    - ユーザー名を含む絶対パス (`C:\Users\username\...`) を直接記述すること（環境変数やチルドを使用せよ）。
- 日本語コメントを徹底すること。
